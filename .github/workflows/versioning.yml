name: Automated Versioning and Release

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  version-and-release:
    name: Determine Version and Create Release
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Get current version
      id: current_version
      run: |
        # Get the latest tag, or default to v0.0.0
        CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
        echo "Current version: $CURRENT_VERSION"

    - name: Get commits since last release
      id: commits
      run: |
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        if [ -z "$LAST_TAG" ]; then
          COMMITS=$(git log --pretty=format:"%H %s" --reverse)
        else
          COMMITS=$(git log --pretty=format:"%H %s" --reverse ${LAST_TAG}..HEAD)
        fi
        
        # Save commits to file for Claude analysis
        echo "$COMMITS" > commits.txt
        echo "Found $(echo "$COMMITS" | wc -l) commits since last release"

    - name: Analyze commits with Claude
      id: analyze
      env:
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      run: |
        # Create the prompt for Claude
        cat > prompt.txt << 'EOF'
        Analyze these git commits and determine the appropriate semantic version bump.
        Current version: ${{ steps.current_version.outputs.version }}
        
        Commits since last release:
        $(cat commits.txt)
        
        Rules:
        - PATCH (0.0.x): Bug fixes, minor updates, documentation changes
        - MINOR (0.x.0): New features, new commands, non-breaking changes
        - MAJOR (x.0.0): Breaking changes, major refactors, API changes
        - Look for conventional commit prefixes: feat:, fix:, docs:, chore:, refactor:, perf:, test:
        - feat! or fix! with ! indicates breaking change (MAJOR)
        - Multiple feat: commits should be MINOR
        - Only fix:, docs:, chore:, test: commits should be PATCH
        
        Also generate release notes with:
        1. A brief summary of the release
        2. List of new features (if any)
        3. List of bug fixes (if any)
        4. List of breaking changes (if any)
        5. List of other changes
        
        Response format (JSON):
        {
          "bump": "patch|minor|major",
          "release_notes": "markdown formatted release notes",
          "summary": "one line summary of the release"
        }
        EOF
        
        # Call Claude API
        RESPONSE=$(curl -s https://api.anthropic.com/v1/messages \
          -H "x-api-key: $ANTHROPIC_API_KEY" \
          -H "anthropic-version: 2023-06-01" \
          -H "content-type: application/json" \
          -d '{
            "model": "claude-3-haiku-20240307",
            "max_tokens": 1000,
            "messages": [{
              "role": "user",
              "content": "'"$(cat prompt.txt | sed 's/"/\\"/g' | tr '\n' ' ')"'"
            }]
          }')
        
        # Extract the JSON response
        echo "$RESPONSE" | jq -r '.content[0].text' > analysis.json
        
        # Parse the results
        BUMP=$(jq -r '.bump' analysis.json)
        RELEASE_NOTES=$(jq -r '.release_notes' analysis.json)
        SUMMARY=$(jq -r '.summary' analysis.json)
        
        echo "bump=$BUMP" >> $GITHUB_OUTPUT
        echo "release_notes<<EOF" >> $GITHUB_OUTPUT
        echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

    - name: Calculate new version
      id: new_version
      run: |
        CURRENT_VERSION="${{ steps.current_version.outputs.version }}"
        BUMP="${{ steps.analyze.outputs.bump }}"
        
        # Remove 'v' prefix for calculation
        VERSION="${CURRENT_VERSION#v}"
        
        # Split version into parts
        IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
        
        # Apply bump
        case "$BUMP" in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
        esac
        
        NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "New version: $NEW_VERSION"

    - name: Update version in project files
      run: |
        # Update version in .csproj files (remove 'v' prefix)
        VERSION_NUM="${{{ steps.new_version.outputs.version }}#v}"
        find . -name "*.csproj" -type f -exec sed -i "s|<Version>.*</Version>|<Version>$VERSION_NUM</Version>|g" {} \;
        find . -name "*.csproj" -type f -exec sed -i "s|<AssemblyVersion>.*</AssemblyVersion>|<AssemblyVersion>$VERSION_NUM</AssemblyVersion>|g" {} \;
        find . -name "*.csproj" -type f -exec sed -i "s|<FileVersion>.*</FileVersion>|<FileVersion>$VERSION_NUM</FileVersion>|g" {} \;
        find . -name "*.csproj" -type f -exec sed -i "s|<PackageVersion>.*</PackageVersion>|<PackageVersion>$VERSION_NUM</PackageVersion>|g" {} \;
        
        # Update version in any AssemblyInfo files
        find . -name "AssemblyInfo.cs" -type f -exec sed -i 's/AssemblyVersion(".*")/AssemblyVersion("${{ steps.new_version.outputs.version }}")/g' {} \;

    - name: Create release commit
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # Check if there are changes to commit
        if [[ -n $(git status -s) ]]; then
          git add -A
          git commit -m "chore: bump version to ${{ steps.new_version.outputs.version }}
          
          ${{ steps.analyze.outputs.summary }}
          
          [skip ci]"
          git push
        fi

    - name: Create and push tag
      run: |
        git tag -a "${{ steps.new_version.outputs.version }}" -m "${{ steps.analyze.outputs.summary }}"
        git push origin "${{ steps.new_version.outputs.version }}"

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.new_version.outputs.version }}
        name: ${{ steps.new_version.outputs.version }} - ${{ steps.analyze.outputs.summary }}
        body: |
          # Release ${{ steps.new_version.outputs.version }}
          
          ${{ steps.analyze.outputs.release_notes }}
          
          ---
          
          **Full Changelog**: ${{ steps.current_version.outputs.version }}...${{ steps.new_version.outputs.version }}
        draft: false
        prerelease: false
        generate_release_notes: false

    - name: Trigger release workflow
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Trigger the release workflow for building artifacts
        gh workflow run release.yml -f version=${{ steps.new_version.outputs.version }} --repo ${{ github.repository }}